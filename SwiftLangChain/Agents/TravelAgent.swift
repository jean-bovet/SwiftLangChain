//
//  TravelAgent.swift
//  SwiftLangChain
//
//  Created by Jean Bovet on 6/3/23.
//

import Foundation

enum AgentError: Error {
    case noLLMAnswer
    case failedToParseAction
    case toolNotFound
}

final class TravelAgent {
    let engine: AIEngine
    let tools: [Tool]

    var toolsPrompt: String {
        var prompt = ""
        for tool in tools.filter({ !$0.finished && $0.enabled }) {
            prompt += "Action name: \(tool.name)"
            prompt += "Action description: \(tool.description)"
            prompt += "\n"
        }
        return prompt
    }

    init(engine: AIEngine, tools: [Tool]) {
        self.engine = engine
        self.tools = tools
    }

    func run(prompt: String, callback: @escaping (String, Bool) -> Void) async throws -> String? {
        // Load the prompt template and fill out the section with the available tools
        let template = try text(fromResourceNamed: "prompt_example")
        let initial = template.replacingOccurrences(of: "$TOOLS$", with: toolsPrompt)

        // Append the question to the root_prompt which is going to be used every time the LLM is queried
        let root_prompt = initial + "\n\nQuestion: " + prompt
        var prompt = root_prompt

        // Keep track of the index of the though in the reasoning chain.
        var index = 1
        while index < 10 {
            // Query the LLM
            print("*******\n\nPrompt:\n\(prompt)")

            let answer = try await engine.ask(prompt: prompt)
            guard let answer else {
                throw AgentError.noLLMAnswer
            }

            print("*******\n\nLLM answered:\n\(answer)")

            // Extract the action corresponding to the index
            let action = try action(response: answer, index: index)

            // Truncate the LLM answer to remove anything after the action we are going
            // to execute, because that text has been generated by the LLM using its
            // own model to generate the tool results, which is not what we want here.
            let truncatedAnswer = truncate(answer: answer, upToAction: action)

            DispatchQueue.main.async {
                callback("LLM:\n" + truncatedAnswer, false)
            }

            // Find out which tool is referenced by the action
            guard let tool = tool(for: action) else {
                throw AgentError.toolNotFound
            }

            // Run the tool
            let result = try tool.run(args: action)

            DispatchQueue.main.async {
                callback("Tool [\(tool.name)] response is:\n" + result, tool.finished)
            }

            if tool.finished {
                // We are done with the reasoning and we have an answer
                return result
            } else {
                // We are not yet done with the reasoning.
                // Rewrite the prompt to include the response of the tool.
                let observation = "Observation \(index): \(result)"
                DispatchQueue.main.async {
                    callback(observation, tool.finished)
                }

                prompt = root_prompt + truncatedAnswer + "\n" + observation
                print("*******\n\nNew prompt is:\n\(prompt)")
            }

            index += 1
        }

        return nil
    }

    func truncate(answer: String, upToAction action: String) -> String {
        guard let range = answer.range(of: action) else {
            fatalError()
        }

        return String(answer[..<range.upperBound])
    }

    func action(response: String, index: Int) throws -> String {
        let lines = response.components(separatedBy: "\n")
        let prefix = "Action \(index):"
        if let action = lines.first(where: { $0.hasPrefix(prefix) }) {
            return String(action.dropFirst(prefix.count).trimmingCharacters(in: .whitespacesAndNewlines))
        } else {
            throw AgentError.failedToParseAction
        }
    }

    func tool(for action: String) -> Tool? {
        for tool in tools {
            if action.hasPrefix(tool.name) {
                return tool
            }
        }
        return nil
    }

    func text(fromResourceNamed named: String) throws -> String {
        guard let url = Bundle.main.url(forResource: named, withExtension: "txt") else {
            fatalError()
        }

        let base = try String(contentsOf: url)
        return base
    }
}
